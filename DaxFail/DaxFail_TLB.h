// ************************************************************************ //
// WARNING
// -------
// The types declared in this file were generated from data read from a
// Type Library. If this type library is explicitly or indirectly (via
// another type library referring to this type library) re-imported, or the
// 'Refresh' command of the Type Library Editor activated while editing the
// Type Library, the contents of this file will be regenerated and all
// manual modifications will be lost.
// ************************************************************************ //

// $Rev: 52393 $
// File generated on 18/03/2014 5:13:08 p.m. from Type Library described below.

// ************************************************************************  //
// Type Lib: F:\work\Cpp\Test\DaxFail\DaxFail (1)
// LIBID: {0A6CC6CE-623E-4455-8B9B-65178FB7585A}
// LCID: 0
// Helpfile:
// HelpString: Library to illustrate failure of Dispatch interface in XE
// DepndLst:
//   (1) v2.0 stdole, (C:\Windows\SysWOW64\stdole2.tlb)
// SYS_KIND: SYS_WIN32
// ************************************************************************ //
#ifndef   DaxFail_TLBH
#define   DaxFail_TLBH

#pragma option push -b -a4 -w-inl -w-8118

#if !defined(__UTILCLS_H)
#include <utilcls.h>
#endif
#if !defined(__UTILCLS_H_VERSION) || (__UTILCLS_H_VERSION < 0x0700)
//
// The code generated by the TLIBIMP utility or the Import|TypeLibrary
// and Import|ActiveX feature of C++Builder rely on specific versions of
// the header file UTILCLS.H found in the INCLUDE\VCL directory. If an
// older version of the file is detected, you probably need an update/patch.
//
#error "This file requires a newer version of the header UTILCLS.H" \
       "You need to apply an update/patch to your copy of C++Builder"
#endif
#include <olectl.h>
#include <ocidl.h>
#if defined(USING_ATLVCL) || defined(USING_ATL)
#if !defined(__TLB_NO_EVENT_WRAPPERS)
#include <atl/atlmod.h>
#endif
#endif

#include <StdVCL.hpp>

typedef TComInterface<System::Win::Stdvcl::IStrings> IStringsPtr;
typedef TComInterface<System::Win::Stdvcl::IStringsDisp> IStringsDispPtr;

namespace Daxfail_tlb
{

// *********************************************************************//
// HelpString: Library to illustrate failure of Dispatch interface in XE
// Version:    1.0
// *********************************************************************//


// *********************************************************************//
// GUIDS declared in the TypeLibrary. Following prefixes are used:
//   Type Libraries     : LIBID_xxxx
//   CoClasses          : CLSID_xxxx
//   DISPInterfaces     : DIID_xxxx
//   Non-DISP interfaces: IID_xxxx
// *********************************************************************//
extern __declspec (package) const GUID LIBID_DaxFail;
extern __declspec (package) const GUID IID_IFoo;
extern __declspec (package) const GUID IID_IBar;
extern __declspec (package) const GUID CLSID_DaxFailClass;

// *********************************************************************//
// Forward declaration of types defined in TypeLibrary
// *********************************************************************//
interface DECLSPEC_UUID("{2CD15FFC-0C09-4A29-BD57-99BBC53AE01F}") IFoo;
typedef TComInterface<IFoo, &IID_IFoo> IFooPtr;

interface DECLSPEC_UUID("{AECB5DF3-EDE3-441A-93E6-220CB271AD43}") IBar;
typedef TComInterface<IBar, &IID_IBar> IBarPtr;


// *********************************************************************//
// Declaration of CoClasses defined in Type Library
// (NOTE: Here we map each CoClass to its Default Interface)
//
// The LIBID_OF_ macro(s) map a LIBID_OF_CoClassName to the GUID of this
// TypeLibrary. It simplifies the updating of macros when CoClass name
// change.
// *********************************************************************//
typedef IFoo DaxFailClass;
typedef IFooPtr DaxFailClassPtr;

#define LIBID_OF_DaxFailClass (&LIBID_DaxFail)
// *********************************************************************//
// Interface: IFoo
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {2CD15FFC-0C09-4A29-BD57-99BBC53AE01F}
// *********************************************************************//
interface IFoo  : public IDispatch
{
public:
  virtual HRESULT STDMETHODCALLTYPE foo_method(void) = 0; // [201]

#if !defined(__TLB_NO_INTERFACE_WRAPPERS)



#endif //   __TLB_NO_INTERFACE_WRAPPERS

};

// *********************************************************************//
// Interface: IBar
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {AECB5DF3-EDE3-441A-93E6-220CB271AD43}
// *********************************************************************//
interface IBar  : public IDispatch
{
public:
  virtual HRESULT STDMETHODCALLTYPE bar_method(void) = 0; // [201]

#if !defined(__TLB_NO_INTERFACE_WRAPPERS)



#endif //   __TLB_NO_INTERFACE_WRAPPERS

};

#if !defined(__TLB_NO_INTERFACE_WRAPPERS)
// *********************************************************************//
// SmartIntf: TCOMIFoo
// Interface: IFoo
// *********************************************************************//
template <class T /* IFoo */ >
class TCOMIFooT : public TComInterface<IFoo>, public TComInterfaceBase<IUnknown>
{
public:
  TCOMIFooT() {}
  TCOMIFooT(IFoo *intf, bool addRef = false) : TComInterface<IFoo>(intf, addRef) {}
  TCOMIFooT(const TCOMIFooT& src) : TComInterface<IFoo>(src) {}
  TCOMIFooT& operator=(const TCOMIFooT& src) { Bind(src, true); return *this;}

  HRESULT         __fastcall foo_method(void);

};
typedef TCOMIFooT<IFoo> TCOMIFoo;

// *********************************************************************//
// DispIntf:  IFoo
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {2CD15FFC-0C09-4A29-BD57-99BBC53AE01F}
// *********************************************************************//
template<class T>
class IFooDispT : public TAutoDriver<IFoo>
{
public:
  IFooDispT(){}

  IFooDispT(IFoo *pintf)
  {
    TAutoDriver<IFoo>::Bind(pintf, false);
  }

  IFooDispT(IFooPtr pintf)
  {
    TAutoDriver<IFoo>::Bind(pintf, true);
  }

  IFooDispT& operator=(IFoo *pintf)
  {
    TAutoDriver<IFoo>::Bind(pintf, false);
    return *this;
  }

  IFooDispT& operator=(IFooPtr pintf)
  {
    TAutoDriver<IFoo>::Bind(pintf, true);
    return *this;
  }

  HRESULT BindDefault()
  {
    return OLECHECK(Bind(CLSID_DaxFailClass));
  }

  HRESULT BindRunning()
  {
    return BindToActive(CLSID_DaxFailClass);
  }

  HRESULT         __fastcall foo_method();

};
typedef IFooDispT<IFoo> IFooDisp;

typedef TComInterface<IBar>  TCOMIBar;

// *********************************************************************//
// DispIntf:  IBar
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {AECB5DF3-EDE3-441A-93E6-220CB271AD43}
// *********************************************************************//
template<class T>
class IBarDispT : public TAutoDriver<IBar>
{
public:
  IBarDispT(){}

  IBarDispT(IBar *pintf)
  {
    TAutoDriver<IBar>::Bind(pintf, false);
  }

  IBarDispT(IBarPtr pintf)
  {
    TAutoDriver<IBar>::Bind(pintf, true);
  }

  IBarDispT& operator=(IBar *pintf)
  {
    TAutoDriver<IBar>::Bind(pintf, false);
    return *this;
  }

  IBarDispT& operator=(IBarPtr pintf)
  {
    TAutoDriver<IBar>::Bind(pintf, true);
    return *this;
  }

  HRESULT         __fastcall bar_method();

};
typedef IBarDispT<IBar> IBarDisp;

// *********************************************************************//
// SmartIntf: TCOMIFoo
// Interface: IFoo
// *********************************************************************//
template <class T> HRESULT __fastcall
TCOMIFooT<T>::foo_method(void)
{
  return (*this)->foo_method();
}

// *********************************************************************//
// DispIntf:  IFoo
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {2CD15FFC-0C09-4A29-BD57-99BBC53AE01F}
// *********************************************************************//
template <class T> HRESULT __fastcall
IFooDispT<T>::foo_method()
{
  _TDispID _dispid(*this, OLETEXT("foo_method"), DISPID(201));
  return OleFunction(_dispid);
}

// *********************************************************************//
// DispIntf:  IBar
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {AECB5DF3-EDE3-441A-93E6-220CB271AD43}
// *********************************************************************//
template <class T> HRESULT __fastcall
IBarDispT<T>::bar_method()
{
  _TDispID _dispid(*this, OLETEXT("bar_method"), DISPID(201));
  return OleFunction(_dispid);
}

// *********************************************************************//
// The following typedefs expose classes (named CoCoClassName) that
// provide static Create() and CreateRemote(LPWSTR machineName) methods
// for creating an instance of an exposed object. These functions can
// be used by client wishing to automate CoClasses exposed by this
// typelibrary.
// *********************************************************************//

// *********************************************************************//
// COCLASS DEFAULT INTERFACE CREATOR
// CoClass  : DaxFailClass
// Interface: TCOMIFoo
// *********************************************************************//
typedef TCoClassCreatorT<TCOMIFoo, IFoo, &CLSID_DaxFailClass, &IID_IFoo> CoDaxFailClass;
#endif  //   __TLB_NO_INTERFACE_WRAPPERS


};     // namespace Daxfail_tlb

#if !defined(NO_IMPLICIT_NAMESPACE_USE)
using  namespace Daxfail_tlb;
#endif

#pragma option pop

#endif // DaxFail_TLBH

